 # STL (Standard Template Library)
 ## C++ STL - 벡터(std::vector), 리스트(list), 데크(deque)
### C++ 표준 템플릿 라이브러리 (Standard Template Library - STL)
1. 컨테이너 (container) : 임의 타입의 객체를 보관할 수 있는 컨테이너(container)
2. 반복자 (iterator) : 컨테이너에 보관된 원소에 접근할 수 있는 반복자 (iterator)
3. 알고리즘 (algorithm) : 반복자들을 가지고 일련의 작업을 수행하는 알고리즘

EX. 우편 배달부가 되어 편지들을 여러개의 편지함에 넣는다는 가정
편지를 보관하는 각각의 편지함들 - '컨테이너'
편지를 보고 원하는 편지함을 찾는 일 - '반복자'
만일 편지들을 편지함에 날짜 순서로 정렬하여 넣는 일 - '알고리즘'

### 한 가지 주목할 만 한점
- 임의 타입의 객체를 보관할 수 있는 컨테이너 (container)
우리가 다루려는 객체가 어떤 특성을 갖는지 무관하게 라이브러리를 자유롭게 사용할 수 있다.(템플릿 덕)
반복자의 도입으로 알고리즘 라이브러리에 필요한 최소한의 코드만을 작성할 수 있게 되었다.
기존, M개 종류의 컨테이너가 있고 N 종류의 알고리즘이 있다면 이 모든 것을 지원하려면 MN 개의 알고리즘 코드가 있어야만 했다.
반복자를 이용해서 컨테이너를 추상화 시켜 접근 할 수 있기 때문. N 개의 알고리즘 코드만으로 M 종류의 컨테이너들을 모두 지원할수 있게 된다.

### C++ `STL` 컨테이너 - 벡터 (std::vector)
-	C++ STL 컨테이너 크게 두 종류
1. 배열처럼 객체들을 순차적으로 보관하는 시퀀스 컨테이너 (sequence container)
2. 키를 바탕으로 대응되는 값을 찾아주는 연관 컨테이너 (associcative container)

1. 시퀀스 컨테이너
	1. vector, list, deque 3개 정의
		1. vector
			1. 가변길이 배열
			2. 원소들이 메모리 상에서 실제로 순차적으로 저장, 임의의 위치에 있는 원소를 매우 빠르게 접근 가능
				1. 얼마나 빠름? O(1) 가장 이상적인 복잡도(마치 전체 데이터를 채 보지 않은 채 작업을 끝낼 수 있다는 의미)
			3. vector 임의의 원소에 접근하는 것 배열처럼[] 사용, at 함수 이용
			4. 맨 뒤에 원소 추가 or 제거 -> push_back 혹은 pop_back 함수 사용
			5. 맨 뒤에 원소를 추가하는 작업은 엄밀히 말하면 amortize O(1) 이라고 함. (amortized의 뜻은 분할상환)
			6. vector의 경우 현재 갖고 있는 원소의 개수 보다 더 많은 공간을 할당 해놓음. 만약 뒤에 새로운 원소를 추가하게 된다면 새롭게 메모리를 할당할 필요없이, 그냥 이미 할당된 공간에 그 원소를 쓰면된다.
			7. 문제가 되는 상황은 할당된 공간을 다 채웠을 경우.
			이 때는 어쩔 수 없이, 새로운 큰 공간을 다시 할당하고, 기존의 원소들을 복사하는 수 밖에 없다. 이 경우 n개의 원소를 모두 복사해야하기 때문에 O(n)으로 수행, 이렇게 수행되는 경우 매우 드물기 때문, 전체적으로 평균을 내보았을 때 O(1)으로 수행된다. 이렇기 때문에 amortized O(1) 이라고 부르게 된다.
			8. 맨 뒤에 원소를 추가하거나 제거하는 것은 빠르지만, 임의의 위치에 원소를 추가하거나 제거하는 것은 O(n) 으로 느리다. 어떤 자리에 새로운 원소를 추가하거나 뺼 경우 그 뒤에 오는 원소들을 한 칸 씩 이동시켜 주어야만 하기 때문. -> n 번의 복사가 필요
			9. 만일 맨 뒤가 아닌 위치에 데이터를 추가하거나 제거하는 작업이 많은 일일 경우 vector 를 사용하면 안된다.
vector 의 복잡도 총 정리
1. 임의의 위치 원소 접근([] , at) : O(1)
2. 맨 뒤에 원소 추가 및 제거 (push_back / pop_back) : amortized O(1); (평균적으로 O(1)이지만 최악의 경우 O(n))
3. 임의의 위치 원소 추가 및 제거 (insert, erase) : O(n)

어떤 작업을 하냐에 따라 속도차가 매우 큼 -> 내가 이 컨테이너를 어떠한 작업을 위해 사용하는 지 정확히 인지하고, 적절한 컨테이너를 골라야함.
---
## 반복자 (iterator)
- 컨테이너 원소에 접근할 수 있는 포인터와 같은 객체.
- 물론 벡터의 경우 [] 를 이용해 정수형 변수로 마치 배열처럼 임의의 위치에 접근 할 수 있지만, 반복자를 사용해서도 마찬가지 작업을 수행 가능.
- 반복자는 컨테이너에 iterator 멤버 타입으로 정의.
- vector 의 경우 반복자를 얻기 위해서 begin() 함수와 end() 함수를 사용할 수 있다.
	- begin() 함수는 첫 번째 원소를 가리키는 반복자를 리턴, end() 함수의 겨우 마지막 원소 한 칸 뒤를 가리키는 반복자를 리턴한다.
	왜?
	begin() == end() 라면, 원소가 없는 벡터를 의미. vec.end() 가 마지막 원소를 가리킨다면 비어있는 벡터를 표현할 수 없게 된다.
- * 연산자를 이용해서 itr 이 가리키는 원소를 볼 수 있다. 물론 itr은 실제 포인터가 아니고 * 연산자를 오버로딩해서 마치 포인터처럼 동작하게 만든 것.
*itr이 가리키는 원소의 레퍼런스를 리턴한다.
(그냥 배열을 가리키는 포인터와 정확히 똑같이 동작한다고 생각하면 된다.)
반복자를 이용하면 아래와 같이 insert 와 erase 함수도 사용할 수 있다.
- 템플릿 버전의 경우 typename 을 추가해줘야한다.
그 이유 -> iterator 가 std::vector<T> 의 의존 타입이기 때문이다.
insert() && erase() 모두 O(n)
vector 에서 반복자로 erase나 insert 함수를 사용할 떄 주의해야 할 점.
컨테이너에 원소를 추가하거나 제거하게 되면 기존에 사용했던 모든 반복자들을 사용할 수 없다.

vector에서 지원하는 반복자로 const_iterator 가 있다. 마치 const 포인터를 생각하면 된다.
즉, const_iterator 의 경우 가리키고 있는 원소의 값을 바꿀 수 없다.
const 반복자가 가리키고 있는 값은 바꿀 수 없다고 오류가 발생한다.
cbegin() && cend() 함수를 이용하여 얻을 수 있다.
반복자의 값을 바꾸지 않고 참조만 하는 경우가 많으므로, const iterator를 적절히 이용하는 것이 좋다.

vector에서 지원하는 반복자 중 마지막 종류로 역반복자 (Reverse iterator) 가 있다.
이는 반복자와 똑같지만 벡터 뒤에서 부터 앞으로 거꾸로 간다는 특징

역반복자의 rend() 역시 맨 앞 원소의 바로 앞을 가리키게 된다.
상수 역반복자도 있다.
const_reverse_iterator 타입
crbegin(), crend() 로 얻을 수 있다.

역반복자를 사용하는 것은 매우 중요하다.
vector의 index를 담당하는 타입이 부호 없는 정수이다.
i = 0 일 때 i-- 를 하게 된다면 -1이 되는 것이 아닌, 해당 타입에서 가장 큰 정수가 된다.
이 문제를 해결하기 위해서는 부호 있는 정수로 선언해야 하는데, 이 경우 vector 의 index 타입과 일치하지 않아서 타입 캐스팅을 해야 한다는 문제가 발생하게 된다.

### 범위 기반 for 문 (range based for loop)
코드를 직관적으로 나타낼수 있어서 매우 편리하다.

## 리스트(list)
양방향 연결 구조를 가진 자료형
- vector 와는 달리 임의의 위치에 있는 원소에 접근을 바로 할 수 없다.
- list 컨테이너 자체에서는 시작 원소와 마지막 원소의 위치만을 기억하기 때문에, 임의의 위치에 있는 원소에 접근하기 위해서는 하나씩 링크를 따라가야 한다.
- [] 나 at 함수가 아예 정의되어 있지 않다.
- vector의 경우 맨 뒤를 제외하고는 임의의 위치에 원소를 추가하거나 제거하는 작업이 O(n) 이였지만, 리스트의 경우 O(1)으로 매우 빠르게 수행될 수 있다.
-> 원하는 위치 아포가 뒤에 있는 링크값만 바꿔주면 되기 때문이다.

리스트의 반복자의 경우 다음과 같은 연산 밖에 수행할 수 없다.
itr++ || itr--
임의의 위치에 있는 원소를 가리킬 수 없다. 오직 한 칸씩 밖에 움직일 수 없다.
메모리 상에서 원소들이 연속적으로 존재하지 않을 수 있는 구조.
리스트에서 정의되는 반복자의 타입을 보면 BidirectionIterator 타입.
양방향으로 이동 가능, 한 칸 씩 밖에 이동 가능.

벡터에서 정의되는 반복자의 타입 -> RandomAccessIterator 타입
즉, 임의의 위치에 접근할 수 있는 반복자. (참고로 RandomAccessIterator는 BidirectionalIterator 를 상속 받고 있다.)

erase 함수를 이용하여 원하는 위치에 있는 원소를 지울 수 도 있다. 리스트의 경우 벡터와 다르게 원소를 지워도 반복자가 무효화 되지 않는다.
왜냐면, 각 원소들의 주소값들은 바뀌지 않기 때문.

## 덱(deque - double ended queue)
- 덱은 벡터와 비슷하게 O(1)으로 임의의 위치의 원소에 접근할 수 있으며 맨 뒤에 원소 추가/제거 작업도 O(1)로 수행할 수 있다.
벡터와 다르게 맨 앞에 원소를 추가/제거 하는 작업까지도 O(1)으로 수행 가능.

임의의 위치에 있는 원소 제거/추가 하는 작업은 벡터와 마찬가디로 O(n)으로 수행 가능.
속도 벡터 < 덱
덱의 경우 벡터와 다르게 원소들이 실제 메모리 상에 연속적으로 존재 하진 않음.
원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가 더 필요.
즉, 덱은 실행 속도를 위해 메모리를 (많이) 희생하는 컨테이너.

벡터와 달리 원소들 연속된 메모리에 존재하는 것이 아닌, 일정 크기로 잘려서 각각의 블록 속에 존재.
이 블록들이 메모리 상에 어느 곳에 위치하여 있는지 저장하지 위해 각각의 블록들의 주소를 저장하는 벡터가 필요

덱이 벡터보다 insert 작업이 더 빠를까?
덱 -> 단순히 새로운 블록을 만들어서 뒤에 추가되는 원소를 넣어주면 된다 -> 기존의 원소들을 복사할 필요가 전혀 없다.
벡터 공간 없을 때 새로운 공간 만들고 복사 붙혀놓기 해줘야해서 평균적으로 덱이 더 빨리 작동.

 덱 역시 벡터 처럼 임의의 위치에 원소에 접근할 수 있으므로 [] 와 at 함수를 제공하고 있고, 반복자 역시 RandomAccessIterator 타입 이고 벡터랑 정확히 동일한 방식으로 작동
 ----
 ## 그래서 어떤 컨테이너를 사용해야 할 까?
 1. 일반적인 상황에서는 그냥 벡터를 사용한다.(만능)
 2. 만약에 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고, 원소들을 순차적으로만 접근한다면 리스트를 사용한다.
 3. 만약에 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이하면 덱을 사용한다.
 ---
 # STL2 - 셋(set), 맵(map), unordered_set, unordered_map
 시퀀스 컨테이너 -> '원소' 자체를 보관하는 테이블
 연관 컨테이너 (associative container) -> 시퀀스와 다르게 키(key) - 값(value) 구조를 가진다.
 특정한 키를 넣으면 대응되는 값을 돌려준다.
 템플릿 라이브러리 이기 때문에 키와 값 모두 임의의 타입의 객체가 될 수 있다.

 ## 셋(set)
 시퀀스와 다른점 -> 어디에 넣을지 정보 없음.
 셋은 어디에 있는지 보다 있냐/없냐가 중요함.

 셋에 원소를 추가하거나 지우는 작업은 O(logN)에 처리된다.
 시퀀스 컨테이너의 경우 임의의 원소를 지우는 작업이 O(N)으로 수행되었다는 점을 생각하면 훨씬 빠르다.

 셋 역시 저장되어 있는 원소들에 접근하기 위해 반복자 제공, 이 반복자는 BidirectionalIterator	.
 임의의 위치에 있는 원소에 접근하는 것은 불가능. 순차적으로 하나씩 접근하는 것 밖에 불가능

 셋의 경우 내부에 원소를 추가할 때 정렬된 상태를 유지하며 추가한다.
 이 때문에 시퀀스 컨테이너와는 다르게 원소를 추가하는 작업이 O(logN)으로 진행.

 find 함수 제공 -> 원소가 존재하는지 아닌지 확인할 수 있다.
 만일 해당 원소 존재 -> 이를 가리키는 반복자를 리턴(std::set<>::iterator 타입) 없을 경우 s.end()를 리턴
 셋의 경우 O(logN)으로 원소가 존재하는 지 확인할수 있다.
 이러한 방식으로 작업을 수행할 수 있는 이유는 바로 내부적으로 트리 구조로 구성되어 있기 때문
 원소를 검색하는데 필요한 횟수는 트리의 높이와 정확이 일치한다.
 따라서, 트리의 경우 최대한 모든 노드들을 꽉채우는 것이 중요하다.
 셋 안에는 중복된 원소들이 없다.
 셋 자체적으로 이미 같은 원소가 있다면 이를 insert 하지 않는다.
 set 역시 범위 기반 for 문을 지원한다.
 원소들의 접근 순서는 반복자를 이용해서 접근하였을 때 와 동일.

 ### 자신이 만든 클래스 객체를 셋에 넣고 싶을 때
 주의해야할 점이 있다.
 operator < 가 정의되어 있지 않다. 따라서 컴파일러는 오류를 내뿜음.
 셋에서 < 를 사용하기 위해선 반드시 위와 같은 형태로 함수를 작성해야한다.
 셋 내부적으로 정렬 시에 상수 반복자를 사용하기 때문.(상수 반복자는 상수 함수만을 호출할 수 있다. 이를 지켜야 하는 이유는 셋 내부적으로 정렬 시에 상수 반복자를 사용하기 때문.) 상수 반복자는 상수 함수만을 호출 할 수 있다.

 operator < 를 설계할 때 반드시 다른 객체는 operator <	상에서도 구분될 수 있도록 만들어야 한다.

 operator < 는 다음과 같은 조건들을 만족해야한다.(A 랑  B 가 다른 객체라면)
A < A 는 거짓
A < B != B < A
A < B 이고 B < C 이면 A < C
A == B 이면  A < B 와 B < A 둘 다 거짓
A == B 이고 B == C 이면 A == C

위 와 같은 조건을 만족하는 < 연산자는 strict weak ordering 을 만족한다고 한다.
상식적으로 opreator < 를 설계했다면 위 조건들을 모두 만족할 수 있다.
만약, 위 중 하나라도 조건이 맞지 않으면 set 이 제대로 동작하지 않고, 런타임 상에서 오류가 발생할텐데 디버깅 하기 힘들거 ㅠ

클래스 자체에 operator < 를 두지 않더라도 셋을 사용하는 방법
외부 라이브러리 사용, 만약 그 라이브러리의 한 클래스의 객체를 셋에 저장하고 싶은 경우. 우리가 사용하는 외부 클래스에 operator < 가 정의 되어 있지 않다는 점.
이럴 경우, 셋을 사용하기 위해선 따로 객체를 비교할 수 있는 방법을 알려줘야함.
----
## 맵 (map)
맵은 셋과 거의 똑같은 자료구조. 다만 셋의 경우 키만 보관, 맵의 경우 키에 대응되는 값까지도 보관
맵에 원소를 넣기 위해선 반드시 std::pair 객체를 전달해야한다.
std::pair
template <class T1, class T2>
struct std::pair {
	T1 first;
	T2 second;
};
단순히 2개의 객체를 멤버로 갖는 객체다.
std::pair 객체를 사용할 때 마다 위처럼 템플릿 인자를 초기화 해야하는데 STL에선 std::make_pair 함수를 제공해준다.
이 함수는 인자로 들어오는 객체를 보고 타입을 추측해서 알아서 std::pair 객체를 만들어서 리턴해준다.
맵의 경우 operator[] 를 이용해서 새로운 원소를 추가할 수 도 있다.(만일 해당하는 키가 맵에 없다면.)
만일 키가 이미 존재하고 있다면 값이 대체될 것이다.
맵의 경우도 셋과 마찬가지로 반복자를 이용해서 순차적으로 맵에 저장되어 있는 원소들을 탐색할 수 있다.
셋의 경우 *itr이 저장된 원소를 바로 가리켰는데, 맵의 경우 반복자가 맵에 저장되어 있는 std::pair 객체를 가리키게 된다. 

for 문을 범위 기반 for 문으로 바꾼다면?
template <typename K, typename V>
void print_map(std::map<K, V>& m) {
  // kv 에는 맵의 key 와 value 가 std::pair 로 들어갑니다.
  for (const auto& kv : m) {
    std::cout << kv.first << " " << kv.second << std::endl;
  }
}

일반 반복자를 사용한 형태보다 간단하므로 권장.

맵에 저장된 값을 찾고 싶다면 간단히 [] 연산자를 이용하면 된다. [] 연산자는 인자로 키를 받아서 이를 맵에 찾아 대응되는 값을 돌려준다.
[] 연산자 맵에 없는 키를 참조하게 되면, 자동으로 값의 디폴트 생성자를 호출해서 원소를 추가해버림.

double 의 디폴트 생성자의 경우 그냥 변수를 0으로 초기화.
되도록 find	함수로 원소가 키가 존재하는지 먼저 확인한 후 값을 참조하느 것이 좋다.
find 함수는 맵에서 해당하는 키를 찾아, 이를 가리키는 반복자를 리턴한다.
키가 존재하지 않는다면 end() 를 리턴함.
맵 역시 셋 처럼 중복된 원소를 허락하지 않는다.
같은 키가 원소로 들어 있다면 나중에 오는 insert는 무시