## C++ 템플릿(Template) 9 -1
사용자가 원하는 타입을 넣어주면 딱딱 알아서 코드를 찍어내는 틀
template <typename T>\
정의 되는 클래스에 대해 템플릿을 정의하고, 템플릿 인자로 T를 받게되며, T는 반드시 어떠한 타입의 이름을 명시\
템플릿 문장 아래 오는 것이 class Vector이므로 ,Vector 클래스에 대한 템플릿을 명시하는데, 만약에 밑에 오는 것이 함수일 경우 함수에 대한 템플시이  된다.\

template <class T>\
라고 쓰는 경우, 이는 정확히 typename T와 동일. class T라고 해서 T자리에 꼭 클래스가 와야하는건 아니다.\

### template <typename T> 와 template <class T> 는 정확히 같은 의미, 되도록이면 typename 키워드 사용

정의한 템플릿의 인자에 값을 전달하기 위해서는
### Vector<int> int_vec;
<> 안에 전달하려는 것을 명시해주면 된다.\
인자로 특정한 '값' 혹은 '객체'를 전달해왔지만, '타입' 그 자체를 전달한 적은 없었다. 하지만 템플릿을 통해 타입을 전달할 수 있게 된다.\
#### Vector<int> || Vector<std::string>
클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화 (class template instantiation) 라고 한다.\

bool 데이터형은 1개 비트만으로 충분히 저장, C++ 기본으로 처리하는 단위가 1byte(8bits)

## 템플릿 특수화 (template specialization)
일부 경우에 대해서 따로 처리하는 것을 템플릿 특수화.\
template <typename A, typename B, typename C>
class test {};\
위와 같이 클래스 템플릿이 정의되어 있을 때\
template <typename B>\
class test<int, B, double> {};\
와 같은 방식으로 작성하면 된다.\
template <>\
class test <int, int, double> {};\
와 같이 써주면 모두 특수화 가능.\
한 가지 중요한 점은, 전달하는 템플릿 인자가 없더라도 특수화 하고 싶다면, template<> 라도 남겨줘야한다.

## 함수 템플릿 (Function template)
클래스 템플릿과 마찬가지로, 함수도 인스턴스화 되기 전 까지는 컴파일 시에 아무런 코드로 변환되지 않는다.\
템플릿 함수가 인스턴스화 되는 부분은 바로 코드에서 호출되는 부분. 클래스를 인스턴스화 할 때와 다르게 <> 하는 부분이 없다.\
기존 템플릿 max<int>(a,b) C++ 컴파일러는 생각보다 똑똑해서, a와 b의 타입을 보고 알아서 max (a, b)를 max<int> (a,b) 로 인스턴스화 해준다.

### 템플릿 메타프로그래밍(template metaprogramming)
컴파일 시에 모든 템플릿들이 인스턴스화 되다는 사실을 갖고 또 여러가지 흥미로운 코드를 작성할 수 있게 해줌.\

Comp1과 Comp2 모두 아무 것도 하지 않고 단순히 operator() 만 정의\
Comp1 과 Comp2 객체들은 bubble_sort 함수 안에서 if (!comp(cont[i], cont[j]))\
함수인양 사용된다.\
### 함수는 아니지만 함수 인 척을 하는 객체를 함수 객체(Function Object), 혹은 줄여서 Functor 라고 부른다.
Functor 덕분에, bubble_sort 함수 내에서 두 객체간의 비교를 사용자가 원하는 대로 할 수 있게 된다.\
Functor 를 사용하는 것이 여러 모로 훨씬 편리한 점이 많다. 일단, 클래스 자체에 여러가지 내부 state를 저장해서 비교자체가 복잡한 경우에도 손쉽게 사용자가 원하는 방식으로 만들어낼 수 있다.\
함수포인터로 함수를 받아서 처리한다면 컴파일러가 최적화를 할 수 없지만, Functor를 넘기게 되면, 컴파일러가 opreator() 자체를 인라인화 시켜서 매우 빠르게 작업을 수행할 수 있다.\

## 타입이 아닌 템플릿 인자 (non-type template arguments)
템플릿 인자로 타입만 받을 수 있는 것은 아니다.\
템플릿 인자로 전달 할 수 있는 타입들이 아래와 같이 제한 적이다.\
1. 정수 타입들(bool, char, int, long 등등). 당연히 float과 double은 제외
2. 포인터 타입
3. enum 타입
4. std::nullptr_t (널포인터)\

기존 C에서의 배열의 가장 큰 문제점은 함수에 배열을 전달할 때 배열의 크기에 대한 정보를 잃어버린다는 점\
템플릿 인자로 배열의 크기를 명시한다면, 위와 같은 문제를 해결 할 수 있다.\
std::array 를 통해 사용할 수 있다.\
std::array<int, 5> arr = {1, 2, 3, 4, 5};\
위 처럼 배열의 원소 타입과 크기를 템플릿 인자로 명시한 뒤에, 초기화만 해주면 된다.\
C에서 배열을 정의할 때 처럼 {} 를 이용해서 생성하며 된다.\
{}는 유니폼 초기화(Uniform initialization)이라 불리는 C++ 11에서 추가된 개념.\
arr은 런타임에서 동적으로 크기가 할당되는 것이 아니다. 마치 배열처럼 컴파일 시에 int 5개를 가지는 메모리를 갖고 스택에 할당된다.\
std::array를 받는 함수를 만들면 안된다. std::array<int, 5> 자체가 하나의 타입이기 때문에.\

void print_array(const std::array<int, 5>& arr)\
문제는 각 array 크기 별로 함수를 만들어줘야한다. -> 템플릿을 사용하여 해결\

## 디폴트 템플릿 인자
함수에 디폴트 인자를 지정할 수 있는 것처럼 템플릿도 디폴트 인자를 지정할 수 있다.\
template <typename T, int num = 5> 위 경우 num에 디폴트로 5가 전달\
타입 역시 디폴트로 지정이 가능\
template <typename T, typename Comp> -> template <typename T, typename Comp = Compare<T>>\
Comp로 디폴트 타입인 Compare<T>가 전달되어서 < 를 통해 비교 수행.
---
## C++ 가변 길이 템플릿 (Variadic template)
템플릿을 사용해서 임의의 개수의 인자를 받는 방법\
template <typename T, typename... Types>\
typename 뒤에 ... 오는 것 템플릿 파라미터 팩(parameter pack) 이라 부름\
템플릿 파리미터 팩의 경우 0개 이상의 템플릿 인자들을 나타낸다.\
함수에 인자로 ... 오는 것을 함수 파라미터 팩이라고 부르며, 0 개 이상의 함수 인자를 나타낸다.\
템플릿 파라미터 팩과 함수 파라미터 팩의 차이점은 템플릿의 경우 타입 앞에 ... 이 오고, 함수의 경우 타입 뒤에 ...이 온다.\
파라미터 팩은 추론된 인자를 제외한 나머지 인자들을 나타내게 된다.\
C++ 규칙 상, 파라미터 팩이 없는 함수의 우선순위가 높기 때문에 첫 번째 print함수가 실행\
만약 함수의 순서를 바꿔 컴파일 했다면 오류 발생\
이유 : C++ 컴파일러는 함수를 컴파일 시에, 자신의 앞에 정의되어 있는 함수들 밖에 보지 못하기 때문\
그러므로 항상 템플릿 함수를 작성할 때 그 순서에 유의해서 써야한다.\

### 임의의 개수의 문자열을 합치는 함수
std::string 에서 문자열을 합치기 위해서는\
concat = s1 + s2 + s3;\
concat = s1.operator+(s2).opreator+(s3); 와 같다.\
 문제는 s2를 더할 때 메모리 할당 발생, s3을 더할 때 메모리 할당이 또 한번 발생할 수 있다는 뜻.\
 합쳐진 문자열의 크기는 미리 알 수 있으니, 차라리 한 번에 필요한 만큼 메모리를 할당해버리는 것이 훨씬 낫다. (메모리 할당/해제는 매우 느린 작업 중 하나)\
 ### sizeof...
 sizeof 연산자는 인자의 크기를 리턴, 파라미터 팩에 sizeof... 을 사용할 경우 전체 인자의 개수를 리턴하게 된다.\

### Fold Expression
C++ 11 에서 도입된 가변 길이 템플릿은 매우 편리하지만 한 가지 단점이 있다.\
재귀 함수 형태로 구성, 반드시 재귀 호출 종료를 위한 함수를 따로 만들어야한다.\
C++ 17 에 새로 도입된 Fold 형식을 사용한다면 이를 훨씬 간단하게 표현\
Fold식을 쓸 때 꼭 () 로 감싸줘야 한다.

## 일반화 프로그래밍(Generic programming)
템플릿 인자로는 타입 뿐만 아니라 특정한 조건을 만족하는 값들도 올 수 있다.\


### 템플릿 메타 프로그래밍 (Template Meta Programming - TMP)
템플릿을 사용하면 객체를 생성하지 않더라도, 타입에 어떠한 값을 부여할 수 있고, 또 그 타입들을 갖고 연산을 할 수 있다.\
타입은 반드시 컴파일 타임에 확정되어야 하므로, 컴파일 타임에 모든 연산이 끝나게 된다.\
타입을 갖고 컴파일 타임에 생성되는 코드로 프로그래밍을 하는 것을\
'메타 프로그래밍(meta programming) 이라 한다.\
C++의 경우 템플릿을 갖고 이러한 작업을 하기 때문에 템플릿 메타 프로그래밍, 줄여서 TMP라고 부른다.\
Factorial 예제에서 '720'이라는 값을 갖고 있는 변수는 메모리 상에 없다.\
단순히 컴파일러가 만들어낸 Factorial<6> 이라는 타입을 나타내고 있을 뿐.\
템플릿으로는 for문을 쓸 수 없다.\

### TMP 를 왜 쓰는가?
템플릿 메타 프로그래밍은 매우 복잡하다.\
템플릿 메타 프로그래밍으로 작성된코드는 버그를 찾는 것이 매우 힘들다.\
'컴파일' 타임에 연산하는 것이기 때문에 디버깅이 불가능 하고, C++ 컴파일러에 특성 상 템플릿 오류 시에 엄청난 길이의 오류를 내뿜는다.\
많은 C++ 라이브러리들이 TMP를 이용해서 구현\
TMP를 통해서 컴파일타임에 여러 오류들을 잡아낼 수 있다.(단위나 통화 일치 여부 등등)\
속도가 매우 중요한 프로그램의 경우 TMP 를 통해서 런타임 속도도 향상 시킬 수 있다.\

컴퓨터 상에서 두 수의 최대공약수를 구하기 위해선 보통 유클리드 호제법을 사용.\

C11++부터 typedef 대신 더 직관적인 using이라는 키워드를 사용할 수 있다.\
typedef Ratio_add<rat1, rat2> rat3;\
using rat3 = Ratio_add<rat1, rat2>;
using을 사용했을 경우 typedef 보다 좀 더 이해하기가 쉽다.\
typedef void(*func)(int, int); == using func = void(*)(int, int);

## 메타2
템플릿 인자에 따라서 어떠한 타입이 달라질 수 있는 것을 의존타입(dependent type)이라 부른다.\
다만, 의존 '값'의 경우 typename을 안 붙여줘도 된다.\
컴파일러는 어떤 식별자를 보았을 때 기본으로 '값'이라 생각한다.\

### 단위(Unit) 라이브러리
다른 단위끼리의 연산은 불가능한 연산이다.\
단위 데이터를 일반적인 변수에 보관하지 말고 클래스를 만들어서 클래스 객체에서 보관하는 것이 안전\
operator+ 등으로 연산자들을 오버로딩 한 뒤에, 연산 시에 객체 끼리 단위를 체크해서 단위가 맞지 않으면 적절히 처리한다.\
만일 틀린 단위를 연산하는 코드가 매우 드물게 일어난다면? -> 런타임에서 그 문제를 발견하지 못한 채 넘어간다면..\
가장 이상적인 상황은 단위가 맞지 않는 연산을 수행하는 코드가 있다면 아예 컴파일 시에 오류를 발생시켜버리는 것.

